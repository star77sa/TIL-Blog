{
  
    
        "post0": {
            "title": "머신러닝 야학 - 머신러닝 1",
            "content": "&#44592;&#44228;&#54617;&#49845;(machine learning) . . &#51648;&#46020;&#54617;&#49845; (supervised learning) . &#48516;&#47448; Classification . 범주형 변수를 예측하고 싶을 때 사용 | . &#54924;&#44480; Regression . 수치형 변수를 예측하고 싶을때 사용 | . &#48708;&#51648;&#46020;&#54617;&#49845; (unsupervised learning) . - 관측치(행)을 그룹핑 해주는 것 -&gt; 군집화 - 특성(열)을 그룹핑 해주는 것 -&gt; 연관규칙 . &#44400;&#51665;&#54868; Clustering . 비슷한 것들을 찾아서 그룹을 만드는 것 | . 지도학습의 분류와는 구분된다. 어떤 대상들을 구분해서 그룹을 만드는 것 - 군집화 | 어떤 대상이 어떤 그룹에 속하는지를 판단하는 것 - 분류 | . | . &#50672;&#44288; Association rule learing . 서로 연관된 특징(열)을 찾아내는 것 | 장바구니 분석 | . &#48320;&#54872; . &#44053;&#54868;&#54617;&#49845; (Reinforcement Learning) . 지도학습이 배움을 통해서 실력을 키우는 것이라면 강화학습은 일단 해보면서 경험을 통해서 실력을 키워가는 것 . 그 행동의 결과가 자신에게 유리한 것이었다면 상을 받고, 불리한 것이었다면 벌을 받는 것 | . 이 과정을 매우 많이 반복하면 더 좋은 답을 찾아낼 수 있다는 것이 강화학습의 기본 아이디어 | .",
            "url": "https://star77sa.github.io/TIL-Blog/data/2021/07/15/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D_%EC%95%BC%ED%95%99-%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D1.html",
            "relUrl": "/data/2021/07/15/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D_%EC%95%BC%ED%95%99-%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D1.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "CatBoost",
            "content": "CatBoost &#53945;&#51669; . Great quality without parameter tuning . Reduce time spent on parameter tuning, because CatBoost provides great results with default parameters | . Categorical features support . Improve your training results with CatBoost that allows you to use non-numeric factors, instead of having to pre-process your data or spend time and effort turning it to numbers. | . Fast and scalable GPU version . Train your model on a fast implementation of gradient-boosting algorithm for GPU. Use a multi-card configuration for large datasets. | . Improved accuracy . Reduce overfitting when constructing your models with a novel gradient-boosting scheme. | . Fast prediction . Apply your trained model quickly and efficiently even to latency-critical tasks using CatBoost&#39;s model applier | . Default Parameter (CatBoost_Regressor) . class CatBoostRegressor(iterations=None, learning_rate=None, depth=None, l2_leaf_reg=None, model_size_reg=None, rsm=None, loss_function=&#39;RMSE&#39;, border_count=None, feature_border_type=None, per_float_feature_quantization=None, input_borders=None, output_borders=None, fold_permutation_block=None, od_pval=None, od_wait=None, od_type=None, nan_mode=None, counter_calc_method=None, leaf_estimation_iterations=None, leaf_estimation_method=None, thread_count=None, random_seed=None, use_best_model=None, best_model_min_trees=None, verbose=None, silent=None, logging_level=None, metric_period=None, ctr_leaf_count_limit=None, store_all_simple_ctr=None, max_ctr_complexity=None, has_time=None, allow_const_label=None, one_hot_max_size=None, random_strength=None, name=None, ignored_features=None, train_dir=None, custom_metric=None, eval_metric=None, bagging_temperature=None, save_snapshot=None, snapshot_file=None, snapshot_interval=None, fold_len_multiplier=None, used_ram_limit=None, gpu_ram_part=None, pinned_memory_size=None, allow_writing_files=None, final_ctr_computation_mode=None, approx_on_full_history=None, boosting_type=None, simple_ctr=None, combinations_ctr=None, per_feature_ctr=None, ctr_target_border_count=None, task_type=None, device_config=None, devices=None, bootstrap_type=None, subsample=None, sampling_unit=None, dev_score_calc_obj_block_size=None, max_depth=None, n_estimators=None, num_boost_round=None, num_trees=None, colsample_bylevel=None, random_state=None, reg_lambda=None, objective=None, eta=None, max_bin=None, gpu_cat_features_storage=None, data_partition=None, metadata=None, early_stopping_rounds=None, cat_features=None, grow_policy=None, min_data_in_leaf=None, min_child_samples=None, max_leaves=None, num_leaves=None, score_function=None, leaf_estimation_backtracking=None, ctr_history_unit=None, monotone_constraints=None, feature_weights=None, penalties_coefficient=None, first_feature_use_penalties=None, model_shrink_rate=None, model_shrink_mode=None, langevin=None, diffusion_temperature=None, posterior_sampling=None, boost_from_average=None) . &#47784;&#45944; Feature &#51473;&#50836;&#46020; &#53456;&#49353; . In short, you can do something like . pd.DataFrame({&#39;feature_importance&#39;: model.get_feature_importance(train_pool), &#39;feature_names&#39;: x_val.columns}).sort_values(by=[&#39;feature_importance&#39;], ascending=False) . you can also make a function like . def plot_feature_importance(importance,names,model_type): #Create arrays from feature importance and feature names feature_importance = np.array(importance) feature_names = np.array(names) #Create a DataFrame using a Dictionary data={&#39;feature_names&#39;:feature_names,&#39;feature_importance&#39;:feature_importance} fi_df = pd.DataFrame(data) #Sort the DataFrame in order decreasing feature importance fi_df.sort_values(by=[&#39;feature_importance&#39;], ascending=False,inplace=True)) #Define size of bar plot plt.figure(figsize=(10,8)) #Plot Searborn bar chart sns.barplot(x=fi_df[&#39;feature_importance&#39;], y=fi_df[&#39;feature_names&#39;]) #Add chart labels plt.title(model_type + &#39;FEATURE IMPORTANCE&#39;) plt.xlabel(&#39;FEATURE IMPORTANCE&#39;) plt.ylabel(&#39;FEATURE NAMES&#39;) . and plot the feature importance from different boosting algorithm . #plot the xgboost result plot_feature_importance(xgb_model.feature_importances_,train.columns,&#39;XG BOOST&#39;) #plot the catboost result plot_feature_importance(cb_model.get_feature_importance(),train.columns,&#39;CATBOOST&#39;) . &#48276;&#51452;&#54805; &#48320;&#49688; &#51648;&#51221;&#54616;&#44592; . x1_train = train[[&#39;Numerical variable&#39;, ... , &#39;Categorical variable&#39;]] y1_train = train[&#39;예측하고 싶은 값&#39;] x1_test = train[[&#39;Numerical variable&#39;, ... , &#39;Categorical variable&#39;]] categorical_features_indices1 = np.where(x1_train.dtypes == np.object)[0] # 이걸로 범주형 변수를 지정 from catboost import CatBoostRegressor cat = CatBoostRegressor(loss_function=&#39;MAE&#39;) model1 = cat model1.fit(x1_train, y1_train, cat_features=categorical_features_indices1) # categorical feature 지정. pred1 = model1.predict(x1_test) submission[&#39;예측하고 싶은 값&#39;] = pred1 submission.to_csv(&#39;catcategory2.csv&#39;, index=False) .",
            "url": "https://star77sa.github.io/TIL-Blog/python/analysis/model/2021/07/15/CatBoost.html",
            "relUrl": "/python/analysis/model/2021/07/15/CatBoost.html",
            "date": " • Jul 15, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "데이터 분석 Dacon",
            "content": "2021.06.29 . EDA . &#46972;&#51060;&#48652;&#47084;&#47532; &#48520;&#47084;&#50724;&#44592; . Pandas 와 Scikit-learn 라이브러리를 불러오세요 | . import pandas as pd from sklearn.tree import DecisionTreeRegressor . &#45936;&#51060;&#53552; &#48520;&#47084;&#50724;&#44592; . train.csv 와 test.csv 를 DataFrame 클래스로 불러오세요 | . pd.read_csv() . train = pd.read_csv(&#39;data/train.csv&#39;) test = pd.read_csv(&#39;data/test.csv&#39;) . &#45936;&#51060;&#53552; &#54665;&#50676; &#44079;&#49688; &#44288;&#52272; . shape 를 사용해 데이터 크기를 관찰하세요 | . df.shape . train.shape . (1459, 11) . test.shape . (715, 10) . &#44208;&#52769;&#52824; &#54869;&#51064; . info() 를 사용해 결측치가 있는지 확인하세요. | . df.info() . train.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 1459 entries, 0 to 1458 Data columns (total 11 columns): # Column Non-Null Count Dtype -- -- 0 id 1459 non-null int64 1 hour 1459 non-null int64 2 hour_bef_temperature 1457 non-null float64 3 hour_bef_precipitation 1457 non-null float64 4 hour_bef_windspeed 1450 non-null float64 5 hour_bef_humidity 1457 non-null float64 6 hour_bef_visibility 1457 non-null float64 7 hour_bef_ozone 1383 non-null float64 8 hour_bef_pm10 1369 non-null float64 9 hour_bef_pm2.5 1342 non-null float64 10 count 1459 non-null float64 dtypes: float64(9), int64(2) memory usage: 125.5 KB . test.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 715 entries, 0 to 714 Data columns (total 10 columns): # Column Non-Null Count Dtype -- -- 0 id 715 non-null int64 1 hour 715 non-null int64 2 hour_bef_temperature 714 non-null float64 3 hour_bef_precipitation 714 non-null float64 4 hour_bef_windspeed 714 non-null float64 5 hour_bef_humidity 714 non-null float64 6 hour_bef_visibility 714 non-null float64 7 hour_bef_ozone 680 non-null float64 8 hour_bef_pm10 678 non-null float64 9 hour_bef_pm2.5 679 non-null float64 dtypes: float64(8), int64(2) memory usage: 56.0 KB . df[&#39;a&#39;].value_counts() . train[&#39;Embarked&#39;].value_counts() . S 644 C 168 Q 77 Name: Embarked, dtype: int64 . df[&#39;a&#39;].unique() . train[&#39;Embarked&#39;].unique() . array([&#39;S&#39;, &#39;C&#39;, &#39;Q&#39;, nan], dtype=object) . pd.Series.plot(kind = &quot;bar&quot;) . 막대 그래프 | index 값이 x축, value값이 y축으로 대응 됩니다. | value_counts()의 결과물을 보여줄 때 유용합니다. | groupby된 결과물을 보여줄 때 유용합니다. | . train.groupby(&#39;Pclass&#39;).mean()[&#39;Survived&#39;].plot(kind=&#39;bar&#39;, rot = 0) # 각도 0 . &lt;AxesSubplot:xlabel=&#39;Pclass&#39;&gt; . pd.Series.plot(kind = &#39;hist&#39;) . 히스토그램: 구간별로 속해있는 row의 개수를 시각화 합니다. | 수치형에서만 가능, 범주는 안됩니다! | . train[&#39;Age&#39;].plot(kind=&#39;hist&#39;, bins = 30) # bins 촘촘한 정도 . &lt;AxesSubplot:ylabel=&#39;Frequency&#39;&gt; . 보조선 =&gt; grid = True . train[&#39;Age&#39;].plot(kind=&#39;hist&#39;, bins = 30, grid=True) # bins 촘촘한 정도 . &lt;AxesSubplot:ylabel=&#39;Frequency&#39;&gt; . pd.DataFrame.plot(x, y, kind = &#39;scatter&#39;) . 산점도: 두 변수간의 관계를 시각화 | . train.plot(x = &#39;Age&#39;, y = &#39;Fare&#39;, kind = &#39;scatter&#39;) . &lt;AxesSubplot:xlabel=&#39;Age&#39;, ylabel=&#39;Fare&#39;&gt; . &#51204;&#52376;&#47532; . &#44208;&#52769;&#52824; &#51204;&#52376;&#47532; . dropna() 를 사용해 train 데이터는 결측치를 제거하고 | fillna() 를 사용해 test 데이터 결측치는 0 으로 대체하세요. | 그리고 결측치의 갯수를 출력하여 확인하세요. | . train = train.dropna() test = test.fillna(0) print(train.isnull().sum()) . id 0 hour 0 hour_bef_temperature 0 hour_bef_precipitation 0 hour_bef_windspeed 0 hour_bef_humidity 0 hour_bef_visibility 0 hour_bef_ozone 0 hour_bef_pm10 0 hour_bef_pm2.5 0 count 0 dtype: int64 . &#44208;&#52769;&#52824; &#45824;&#52404;&#54217;&#44512; . train.fillna({&#39;hour_bef_temperature&#39; : int(train[&#39;hour_bef_temperature&#39;].mean())},inplace=True) . &#44208;&#52769;&#52824; &#45824;&#52404;&#48372;&#44036; . 피쳐의 정보성을 강조하기 위한 보간법 사용 | 데이터의 순서가 시간 순서인 경우에 결측치들을 이전 행(직전시간)과 다음 행(직후시간)의 평균으로 보간하는 것은 상당히 합리적 | 이처럼 데이터에 따라서 결측치를 어떻게 대체할지 결정하는 것은 엔지니어의 결정. . | Python pandas의 interpolate() 를 이용해 결측치를 DataFrame 값에 선형으로 비례하여 보간하는 코드 . train.interpolate(inplace=True) . | . pd.Series.map() . 시리즈 내 값을 변환할 때 사용하는 함수 | 문자열의 경우 숫자형으로 대체해주어야함. 모델에 넣기위해서 | . train = train[&#39;Sex&#39;].map({&#39;male&#39; : 0, &#39;female&#39; : 1}) . &#47784;&#45944; &#54984;&#47144; . train 데이터의 count 피쳐를 뺀 것을 X_train 으로 할당하세요. | train 데이터의 count 피쳐만을 가진 것을 Y_train 으로 할당하세요. | 회귀의사결정나무를 선언하고 fit() 으로 훈련시키세요. | . X_train = train.drop([&#39;count&#39;], axis=1) Y_train = train[&#39;count&#39;] model = DecisionTreeRegressor() model.fit(X_train, Y_train) . DecisionTreeRegressor(ccp_alpha=0.0, criterion=&#39;mse&#39;, max_depth=None, max_features=None, max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, presort=&#39;deprecated&#39;, random_state=None, splitter=&#39;best&#39;) . &#53580;&#49828;&#53944; &#54028;&#51068; &#50696;&#52769; . predict() 을 이용해 test data 를 훈련한 모델로 예측한 data array 를 생성하세요. | . pred = model.predict(test) . submission &#54028;&#51068; &#49373;&#49457; . submission.csv 를 불러오세요. | submission df 의 count 피쳐에 예측한 결과를 덧입히세요. | submission df 를 to_csv() 를 이용해 csv 을 생성하세요. *index=False) | . submission = pd.read_csv(&#39;data/submission.csv&#39;) submission[&#39;count&#39;] = pred submission.to_csv(&#39;sub.csv&#39;,index=False) . . 2021.07.24 &#52628;&#44032; . &#45936;&#51060;&#53552; &#49688;&#51221; . 특정열의 특정행 값 바꾸기 | . train[&#39;석식계&#39;][973] = 479.8605851979346 . &#54596;&#53552;&#47553;&#54616;&#50668; &#45936;&#51060;&#53552; &#49688;&#51221; . df.iloc[ , ] . train.iloc[1,2] = 498 . &#45936;&#51060;&#53552; &#52628;&#52636;, &#51064;&#45937;&#49905; . df.groupby() . train.groupby(&#39;년&#39;).mean()[[&#39;중식계&#39;,&#39;석식계&#39;]] . 중식계 석식계 . 년 | | | . 2016 | 932.792952 | 519.418502 | . 2017 | 897.614754 | 459.015822 | . 2018 | 882.903766 | 465.547534 | . 2019 | 850.512195 | 447.336832 | . 2020 | 882.267241 | 432.736468 | . 2021 | 1009.705882 | 396.588235 | . df.query . df.sort_values() . train.query(&#39;월&lt;4 &amp; 월&gt;1 &amp; 년 == 2020&#39;).mean()[&#39;중식계&#39;] . 952.4285714285714 . train.query(&#39;년&gt;2016&#39;).groupby(&#39;월&#39;).mean()[&#39;중식계&#39;].sort_values() . 월 11 815.963415 12 834.473684 8 838.253012 7 839.523256 6 840.333333 5 849.460526 4 880.225000 10 894.666667 9 901.842857 1 934.278351 3 952.829268 2 998.042857 Name: 중식계, dtype: float64 . &#53945;&#51221; &#45936;&#51060;&#53552; &#46300;&#46989; . df.drop() . 특정 행 데이터 드랍 | . train = train.drop(train.index[[204, 224, 244, 262, 281, 306, 327, 346, 366, 392, 410, 828, 853, 872, 890, 912, 932, 955, 973, 993, 1166]]) . 특정 열 데이터 드랍 | . df.drop(&#39;열 이름&#39;, axis=1) .",
            "url": "https://star77sa.github.io/TIL-Blog/python/analysis/2021/06/29/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D.html",
            "relUrl": "/python/analysis/2021/06/29/%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D.html",
            "date": " • Jun 29, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Python입문",
            "content": ". 0&#52264;&#50896; &#51088;&#47308;&#54805; . int&#54805; . float&#54805; . complex&#54805; . 파이썬 빌트인함수 . https://docs.python.org/3.8/library/functions.html | . 1&#52264;&#50896; &#51088;&#47308;&#54805; . str&#54805; . &#47928;&#51088;&#50676; &#50741;&#49496; . print(&#39;나는 n고경수&#39;) # 한줄띄우기 . 나는 고경수 . print(&#39;나는 t고경수&#39;) # 탭 . 나는 고경수 . print(&#39; &#39;) # 이스케이프 . . print(&#39;나는 n고경수&#39;) . 나는 n고경수 . print(&#39;나는 &#39;고경수 &#39;&#39;) . 나는&#39;고경수&#39; . print(&quot;나는&#39;고경수&#39;&quot;) . 나는&#39;고경수&#39; . &#47928;&#51088;&#50676; &#47700;&#49548;&#46300; . .replace() . S = &#39;xxxxSPAMxxxxSPAMxxxx&#39; S.replace(&#39;SPAM&#39;,&#39;EGGS&#39;) . &#39;xxxxEGGSxxxxEGGSxxxx&#39; . S.replace(&#39;SPAM&#39;,&#39;EGGS&#39;,1) . &#39;xxxxEGGSxxxxSPAMxxxx&#39; . .find() . S = &#39;xxxxSPAMxxxxSPAMxxxx&#39; . where=S.find(&#39;SPAM&#39;) . S[where] . &#39;S&#39; . .join() . &#39;-&#39;.join([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]) . &#39;a-b-c&#39; . S=&#39;spammy&#39; S[3:5]=&#39;xx&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-178-5854ec3fa955&gt; in &lt;module&gt; 1 S=&#39;spammy&#39; -&gt; 2 S[3:5]=&#39;xx&#39; TypeError: &#39;str&#39; object does not support item assignment . mm을 xx로 바꾸고 싶은데 문자열은 불변리스트라서 바꿀 수 없다. . 전략: 문자열을 잠시 가변객체인 리스트로 바꾼뒤 리스트에서 자유롭게 편집하고 그 다음에 다시 문자열로 만들자. . L=list(S) L . [&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;x&#39;, &#39;x&#39;, &#39;y&#39;] . L[3:5] . [&#39;x&#39;, &#39;x&#39;] . L[3:5]=[&#39;x&#39;,&#39;x&#39;] L . [&#39;s&#39;, &#39;p&#39;, &#39;a&#39;, &#39;x&#39;, &#39;x&#39;, &#39;y&#39;] . S=&#39;&#39;.join(L) S . &#39;spaxxy&#39; . .split(&#39;,&#39;) . s=&#39;bob,hacker,40&#39; . s.split(&#39;,&#39;) . &#47928;&#51088;&#50676; &#54252;&#47607;&#54021; . &#54364;&#54788;&#49885; (&#47928;&#51088;&#50676;&#50640;&#49436; %&#50672;&#49328;&#51088; &#49324;&#50857;) . &#39;addr: %s to %s&#39; % (&#39;seoul&#39;,&#39;jeonju&#39;) . 잘못된 사용예시1 (리스트는 안됨) . &#39;addr: %s to %s&#39; % [&#39;seoul&#39;,&#39;jeonju&#39;] . TypeError Traceback (most recent call last) &lt;ipython-input-190-8a70b358fe3b&gt; in &lt;module&gt; -&gt; 1 &#39;addr: %s to %s&#39; % [&#39;seoul&#39;,&#39;jeonju&#39;] TypeError: not enough arguments for format string . 잘못된 사용예시2 (묶지않아도 안됨) . &#39;addr: %s to %s&#39; % &#39;seoul&#39;,&#39;jeonju&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-192-0c8ecede52e2&gt; in &lt;module&gt; -&gt; 1 &#39;addr: %s to %s&#39; % &#39;seoul&#39;,&#39;jeonju&#39; TypeError: not enough arguments for format string . % 연산자는 왼쪽에 문자열 오브젝트, 그리고 오른쪽에는 명시적인 튜플이 있어야 연산이 진행된다. . 연산자라는 포인트를 이해하면 아래와 같은 문법도 가능함을 알 수 있다. . s = &#39;addr: %s to %s&#39; s % (&#39;seoul&#39;,&#39;jeonju&#39;) . &#39;addr: seoul to jeonju&#39; . .format &#47700;&#49436;&#46300; . &#39;이름:{},나이:{},성별:{}&#39;.format(&#39;고경수&#39;,&#39;24&#39;,&#39;남&#39;) . &#39;이름:고경수,나이:24,성별:남&#39; . list&#54805; . 메소드 . del a[0] a.append(&#39;a&#39;) a.index(&#39;a&#39;) a.remove(&#39;a&#39;) . &#47532;&#49828;&#53944;&#52980;&#54532;&#47532;&#54760;&#49496; . 리스트를 매우 효율적으로 만드는 테크닉 | for문에 비하여 가지고 있는 장점: (1) 코드가 간단하다. (2) 빠르다. | . x=[2**i for i in [0,1,2,3,4,5]] x . [1, 2, 4, 8, 16, 32] . [i+j for i in [&#39;stat&#39;,&#39;math&#39;] for j in &#39;12345&#39;] . [&#39;stat1&#39;, &#39;stat2&#39;, &#39;stat3&#39;, &#39;stat4&#39;, &#39;stat5&#39;, &#39;math1&#39;, &#39;math2&#39;, &#39;math3&#39;, &#39;math4&#39;, &#39;math5&#39;] . [i+j for i in &#39;XY&#39; for j in &#39;123&#39;] . [&#39;X1&#39;, &#39;X2&#39;, &#39;X3&#39;, &#39;Y1&#39;, &#39;Y2&#39;, &#39;Y3&#39;] . &#47532;&#49828;&#53944;&#51032; &#51473;&#52393; . a=[[11,12,13], [21,22,23], [31,32,33]] . a . [[11, 12, 13], [21, 22, 23], [31, 32, 33]] . a[0][0] . 11 . a[0][1] . 12 . 0 1 2 . 0 | 11 | 12 | 13 | . 1 | 21 | 22 | 23 | . 2 | 31 | 32 | 33 | . 2차원 배열의 느낌!!! . | 1차원 배열을 사실상 다차원배열로 확장할 수 있는 아이디어를 제공 . | . tuple&#54805; . 리스트와 비슷하다. | 차이점1: [ ] 대신에 ( )를 사용한다. | 차이점2: 불변형이다. (값을 바꿀 수 없음) | 차이점3: 하나의 원소로 이루어진 튜플을 만들때는 쉼표를 붙여야 함. | . a=(1,) a . (1,) . a + (2,) . (1, 2) . 차이점4: (의미가 명확할때) 튜플의 괄호는 생략가능하다. | . a=1,2 a . (1, 2) . 의미가 명확할때 생략해야함 . 1,2 + 3,4,5 . (1, 5, 4, 5) . &#53916;&#54540; &#50616;&#54056;&#53433; . name,age,sex,height,weight = &#39;Tom&#39;,20,&#39;M&#39;,180,70 . name . &#39;Tom&#39; . weight . 70 . [예제3]: 임시변수 사용없이 두 변수의 값을 교환 . a=10 b=20 . a,b=b,a . a . 20 . b . 10 . [예제4]: 함수의 입력으로 튜플을 넣을때 . def cal(a,b): print(str(a) + &#39;+&#39; + str(b) + &#39;=&#39; + str(a+b)) print(str(a) + &#39;-&#39; + str(b) + &#39;=&#39; + str(a-b)) print(str(a) + &#39;*&#39; + str(b) + &#39;=&#39; + str(a*b)) print(str(a) + &#39;/&#39; + str(b) + &#39;=&#39; + str(a/b)) . input=[3,4] cal(input) # 리스트로는 불가능하다. . TypeError Traceback (most recent call last) &lt;ipython-input-61-3191852bf0a7&gt; in &lt;module&gt; 1 ### 우리가 원하는 형태 2 input=[3,4] -&gt; 3 cal(input) # 리스트로는 불가능하다. TypeError: cal() missing 1 required positional argument: &#39;b&#39; . cal(input[0],input[1]) . 3+4=7 3-4=-1 3*4=12 3/4=0.75 . input=(3,4) input . (3, 4) . cal(*input) # 튜플 언패킹으로는 가능하다. . 3+4=7 3-4=-1 3*4=12 3/4=0.75 . 함수를 호출할때 인수앞에 *를 붙여 튜플을 언패킹할 수 있다. | . [예제6]: 플레이스홀더 . idlist=[(&#39;guebin&#39;, &#39;202112345&#39;,&#39;M&#39;,&#39;Korea&#39;), (&#39;iu&#39;, &#39;202154321&#39;,&#39;F&#39;,&#39;Korea&#39;), (&#39;hodong&#39;, &#39;201812321&#39;,&#39;M&#39;,&#39;Korea&#39;)] . for name,studentid,sex,nat in idlist: print(name) . guebin iu hodong . for name , _ , _ , _ in idlist: print(name) . guebin iu hodong . set&#54805; . A={&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;} B={&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;f&#39;} . A.union(B) . {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;} . A|B . {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;} . A.intersection(B) . {&#39;c&#39;, &#39;d&#39;} . A &amp; B . {&#39;c&#39;, &#39;d&#39;} . A.difference(B) . {&#39;a&#39;, &#39;b&#39;} . A-B . {&#39;a&#39;, &#39;b&#39;} . a=set(&#39;hello&#39;) a . {&#39;e&#39;, &#39;h&#39;, &#39;l&#39;, &#39;o&#39;} . for i in a: print(i) . o l e h . 순서가 좀 이상하다 $ to$ 집합은 원래 순서가 없다. $ to$ 인덱싱이 불가능하다. $ to$ 슬라이싱도 불가능 . 집합 컴프리헨션 | . C={2**x for x in [1,2,3,4]} C . {2, 4, 8, 16} . dict&#54805; . mydict={&#39;a&#39;:[1,2,3],&#39;b&#39;:[3,4,5]} . mydict[&#39;a&#39;] . [1, 2, 3] . mydict[&#39;a&#39;]+mydict[&#39;b&#39;] . [1, 2, 3, 3, 4, 5] . mydict[0] # 인덱싱 불가능 . KeyError Traceback (most recent call last) &lt;ipython-input-88-857b2cc4f569&gt; in &lt;module&gt; -&gt; 1 mydict[0] # 인덱싱 불가능 KeyError: 0 . - 딕셔너리 컴프리핸션 . File &#34;&lt;ipython-input-89-235de1d2ec14&gt;&#34;, line 1 - 딕셔너리 컴프리핸션 ^ SyntaxError: invalid syntax . X={x:x**2 for x in [1,2,3,4]} X . {1: 1, 2: 4, 3: 9, 4: 16} . numpy . [$ ast$] &#45336;&#54028;&#51060;(numpy)&#47484; &#50780; &#50024;&#50556; &#54616;&#45716;&#44032;? (1) . 욕심: (1,2,3)+(2,3,4)=(3,5,7)를 계산하고 싶다. . import numpy as np a=np.array((1,2,3)) b=np.array([2,3,4]) a+b . array([3, 5, 7]) . [$ ast$] &#45336;&#54028;&#51060;&#51032; &#54840;&#54872;&#49457; . list - tuple - np.array사이에는 호환성이 좋음 . list(np.array(tuple(a))) . [1, 2, 3] . [$ ast$] &#45336;&#54028;&#51060;(numpy)&#47484; &#50780; &#50024;&#50556;&#54616;&#45716;&#44032;? (2) . 넘파이를 사용하면 벡터연산과 행렬연산을 쉽게 할 수 있다. . 예를들어 아래와 같은 문제가 있다고 하자. . $ begin{cases} w+2x+3y+4z=1 2w+2x+y=9 x-y=4 3w+x-y+3y=7 end{cases}$ . 매트릭스 형태로 위의 식을 표현하면 아래와 같다. . $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix} begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 9 4 7 end{bmatrix}$ . 양변에 $ begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}$의 역행렬을 취하면 . $ begin{bmatrix} w x y z end{bmatrix}= begin{bmatrix} 1 &amp; 2 &amp; 3 &amp; 4 2 &amp; 2 &amp; 1 &amp; 0 0 &amp; 1 &amp;-1 &amp; 0 3 &amp; 1 &amp;-1 &amp; 3 end{bmatrix}^{-1} begin{bmatrix} 1 9 4 7 end{bmatrix}$ . from numpy.linalg import inv A=[[1,2,3,4],[2,2,1,0],[0,1,-1,0],[3,1,-1,3]] b=[1,9,4,7] Aarr=np.array(A) barr=np.array(b) inv(Aarr) @ barr . array([ 2., 3., -1., -1.]) . 인덱싱 (슬라이싱 포함) | . A=np.array([[11,12,13,14,15],[21,22,23,24,25],[31,32,33,34,35]]) A . array([[11, 12, 13, 14, 15], [21, 22, 23, 24, 25], [31, 32, 33, 34, 35]]) . [예제1] (3,1)에 접근하여 보자! . A[2][0] . 31 . A[2,0] # list와의 차이점 . 31 . [예제4] 1행중에서 1,3,5열에 접근해보자. . A[0,[0,2,4]] #방법 1 . array([11, 13, 15]) . A[0][[0,2,4]] #방법 2 . array([11, 13, 15]) . b=(0,2,4) A[0,b] . array([11, 13, 15]) . [$ ast$] &#51064;&#45937;&#49905;&#51032; &#51333;&#47448; ($ star star star$) . 기본인덱싱: 인덱스, 슬라이싱을 활용 예1: A[1,1] | 예2: A[1,0:2] | . | 팬시인덱싱(응용인덱싱): 인덱스를 정수배열로 전달, np.ix_함수를 활용한 인덱싱, 부울값 인덱싱 예1: A[0,[0,2,4]] , 정수배열 인덱싱 | 예2: A[np.ix_(a,b)] , np.ix함수를 활용한 인덱싱 | 예3: c[c&gt;0] , 부울값인덱싱 | . | numpy를 배우는 방법 | . 인터넷+자동완성+contextual help . pandas . `dict`와 호환성이 좋은 새로운 자료형이 있는데, 그것이 바로 `pandas`이다. . 근본적인 차이: list는 번호로, dict는 keyword로 접근한다. . 인덱싱, 슬라이싱 vs 맵핑 note: 리스트는 키워드로 정보검색이 불가능하다. note: 딕셔너리는 인덱스로 정보검색이 불가능하다. | . d={&#39;새로이&#39;:[30,600,4.0], &quot;이서&quot;:[20,950,4.2], &quot;일권&quot;:[28,950,2.3], &quot;현이&quot;:[28,650,3.8]} . import pandas as pd pd.DataFrame(d) ## 판다스자료형 = 데이터프레임을 선언하는 방법 . 새로이 이서 일권 현이 . 0 30.0 | 20.0 | 28.0 | 28.0 | . 1 600.0 | 950.0 | 950.0 | 650.0 | . 2 4.0 | 4.2 | 2.3 | 3.8 | . df=pd.DataFrame(d).T df . 0 1 2 . 새로이 30.0 | 600.0 | 4.0 | . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . 현이 28.0 | 650.0 | 3.8 | . note: 이서의 정보를 알고 싶다면? (딕셔너리 느낌) . df.loc[&#39;이서&#39;] . 0 20.0 1 950.0 2 4.2 Name: 이서, dtype: float64 . note: 칼럼이름을 정하고 싶다면? . df.columns=[&#39;age&#39;,&#39;toeic&#39;,&#39;gpa&#39;] df . age toeic gpa . 새로이 30.0 | 600.0 | 4.0 | . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . 현이 28.0 | 650.0 | 3.8 | . df.loc[:,&#39;gpa&#39;] . 새로이 4.0 이서 4.2 일권 2.3 현이 3.8 Name: gpa, dtype: float64 . note: 2-3번째 칼럼을 불러오자! (넘파이느낌) . df.iloc[:,1:3] . toeic gpa . 새로이 600.0 | 4.0 | . 이서 950.0 | 4.2 | . 일권 950.0 | 2.3 | . 현이 650.0 | 3.8 | . note: 토익점수를 불러오고 싶다면? . df.loc[:,&#39;toeic&#39;] . 새로이 600.0 이서 950.0 일권 950.0 현이 650.0 Name: toeic, dtype: float64 . note: age~toeic까지의 정보를 얻고 싶다면? . df.loc[:,&#39;age&#39;:&#39;toeic&#39;] . age toeic . 새로이 30.0 | 600.0 | . 이서 20.0 | 950.0 | . 일권 28.0 | 950.0 | . 현이 28.0 | 650.0 | . note: 새로이~일권까지의 정보를 얻고 싶다면? . df.loc[&#39;새로이&#39;:&#39;일권&#39;,:] . age toeic gpa . 새로이 30.0 | 600.0 | 4.0 | . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . note: 토익점수가 800보다 높은사람을 부르고 싶다면? . df.query(&#39;toeic&gt;800&#39;) . age toeic gpa . 이서 20.0 | 950.0 | 4.2 | . 일권 28.0 | 950.0 | 2.3 | . note: 나이가 23보다 많고 토익점수가 800보다 높은 사람을 부르고 싶다면? . df.query(&#39;age&gt;23 &amp; toeic&gt;800&#39;) . age toeic gpa . 일권 28.0 | 950.0 | 2.3 | . Class . 많은 교재에서 정의를 회피함 | 비유적 설명 , 다른 대상을 가져와서 설명 클래스는 과자틀과 비슷하다. 클래스란 똑같은 무엇인가를 계속 만들어 낼 수도 있는 설계도면이고 객체란 클래스로 만든 피조물을 뜻한다. (점프투파이썬) | In object-oriented programming, a class is an extensible program-code-template for creating objects, providing initial values for state (member variables) and implementations of behavior (member functions or methods).` | . | . 직접적 설명 복제를 위한 확장가능한 프로그램 코드의 유닛 | . | . 좀더 정리하여 말하면, . (1) 개념의 인지 . (2) 복사하고 싶은 속성을 추림 . (3) 복사가능한 어떤 틀을 만듬 (=클래스를 정의) . (4) 틀에서 인스턴스를 만든다 (=클래스에서 인스턴스를 만든다) . class MooYaHo(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(self): ### 클래스안에서 정의된 함수* print(self.title) display(self.img) print(self.don) . 규칙1: 클래스내에서 함수를 선언하면 반드시 첫번째 인자는 self를 넣어야 한다. --&gt; self가 뭘까? . 규칙2: 클래스 내에서 정의한 변수 (예를들면 title, img, don)를 사용하려면 . self.title, self.img, self.don | MooYaHo.title, MooYaHo.img, MooYaHo.don | . 클래스에서 인스턴스를 찍어내는 방법 . 함수사용법과 비슷 | 클래스 이름을 쓰고 콘텐츠를 구체화시키는 과정에서 필요한 입력1, 입력2를 ()에 넣는다. | MooYaHo의 경우는 따로 입력이 없으므로, 그냥 MooYaHo하고 입력을 비워둔다. 즉 MooYaHo()로 생성 | . 성능1: 인스턴스에서 .을 찍고 접근할 수 있는 여러 자료들을 정의할 수 있다. . 성능2:인스턴스에서 .을 찍고 쓸 수 있는 자체적인 함수(=method라고 함)를 정의할 수 있다. . 출력만 살짝 바꾸어서 MooYaHo2를 만들고 싶다. | . --&gt; MooYaHo의 모든 내용은 그대로 가져오고, 그 살짝만 다시 조정하면 된다. . #### 이런식으로 할 필요 없다. class MooYaHo2(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(self): ### 클래스안에서 정의된 함수* print(&#39;☆☆☆☆☆☆[&#39;+self.title+&#39;]☆☆☆☆☆☆&#39;) display(self.img) print(&#39;형돈:&#39;+self.don) . class MooYaHo2(MooYaHo): choi=&#39;무야~~~~~호~~~!!!&#39; def memeshow(self): ### 클래스안에서 정의된 함수* print(&#39;☆☆☆☆☆☆[&#39;+self.title+&#39;]☆☆☆☆☆☆&#39;) display(self.img) print(self.choi) print(&#39;형돈:&#39;+self.don) . __str__ . __repr__ . __init__ . 상속 . | 객체임베딩(객체 내장) . | . Name Space . 전역 변수 &gt; 클래스 변수 &gt; 메소드 변수 &gt; 인스턴스 변수 | . &#50672;&#49328;&#51088; &#50724;&#48260;&#47196;&#46377; . - 연산자 오버로드 핵심아이디어 . 클래스가 일반 파이썬 연산을 재정의하는 것 | 여기에서 연산은 단순히 더하기 빼기를 의미하는게 아니라, print(), +, [0] 와 같은 파이썬 내장문법을 모두 포괄하는 개념이라 이해하는 것이 옳다. | . if&#47928; . a=11 if a&lt;5: print(&#39;a=....1,2,3,4&#39;) elif a&gt;10: print(&#39;a=11,12,13,....&#39;) else: print(&#39;a=5,6,7,...,10&#39;) . a=11,12,13,.... . a=2 if a==1: print(&#39;a=1&#39;) . if만 있어도 작동한다. . for&#47928; . for i in [1,2,3,4]: print(i) for i in (1,2,3,4): print(i) for i in &#39;1234&#39;: print(i) 1 2 3 4 . - 의문 . for i in ???: print(i) . 에서 물음표 자리에 올 수 있는 것이 무엇일까? . ??? 자리에 올 수 있는 것은 dir()하여 __iter__()라는 메서드가 있는 object이다. . a=1 . dir(a) [&#39;__abs__&#39;, &#39;__add__&#39; . . . . . . `to_bytes&#39;] . int클래스의 인스턴스는 __iter__()가 없다! . - list, pd.DataFrame, np.array 는 모두 __iter__() 함수가 있다. 따라서 iterable한 오브젝트이다. . iterable한 오브젝트는 iterator로 만들 수 있는 특징이 있다. . iterable한 오브젝트를 어떻게 iterator로 만드는가? . L=[[1,2,3],[3,4,5]] import pandas as pd df=pd.DataFrame(L) . dfiter1=df.__iter__() . dfiter2=iter(df) . dfiter1? . Type: generator String form: &lt;generator object RangeIndex.__iter__ at 0x000001A97812A350&gt; Docstring: &lt;no docstring&gt; . - dfiter1은 generator라는 클래스에서 만들어진 인스턴스 오브젝트이다. . dir(dfiter1) . [&#39;__class__&#39;, &#39;__del__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__name__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__next__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;gi_code&#39;, &#39;gi_frame&#39;, &#39;gi_running&#39;, &#39;gi_yieldfrom&#39;, &#39;send&#39;, &#39;throw&#39;] . dfiter1.__next__() . 0 . – for 문의 작동원리 . for i in L: print(i) . (1) iter함수를 사용해서 L을 iterator로 만든다. . (2) iterator에서 .__next__()함수를 호출하고 결과를 i에 저장한뒤에 for문 블락안에 있는 내용(들여쓰기 된 내용)을 실행한다. . (3) StopIteration 에러가 발생하면 for 문을 멈춘다. . Liter=iter(L) . Liter.__next__() . [1, 2, 3] . Liter.__next__() . [3, 4, 5] . Liter.__next__() . StopIteration Traceback (most recent call last) &lt;ipython-input-228-6220b29182a4&gt; in &lt;module&gt; -&gt; 1 Liter.__next__() StopIteration: . range() . - for문의 정석은 아래와 같이 range()를 사용하는 것이다. . for i in range(5): print(i) . 0 1 2 3 4 . - range(5)의 정체는 그냥 iterable object이다. . - 그래서 언제든지 iterator로 바꿀 수 있다. . a = range(5) aiter=iter(a) . aiter.__next__() . 0 . aiter.__next__() . 1 . . . . . aiter.__next__() . StopIteration Traceback (most recent call last) &lt;ipython-input-238-b0a1ab28475b&gt; in &lt;module&gt; -&gt; 1 aiter.__next__() StopIteration: . - ???? 자리에 iterator 자체가와도 무방할것 같다. . - 확인 . L=iter([1,2,3,4]) for i in L: print(i) . 1 2 3 4 . with . f=open(&#39;test.txt&#39;) a=f.read() print(a) hello hello2 hello3 f.closed . false . f.close() f.closed . True . f가 닫힌 상태에서는 더 이상 읽을 수가 없다. . 파일을 닫지 않는다고 해서 큰 문제는 없어보이지만 그냥 닫는것이 좋다. . motivation | . - 생각해 보니까 파일을 열면 항상 닫아야 한다. . 이처럼 쌍(시작-끝)으로 수행되는 처리가 반복적으로 발생하는 경우가 있는데 그때마다 .close() 메소드 따위를 쓰는 것이 번거롭게 느껴진다. . 예를들면 파일을 열었으면 적당한 동작뒤에 알아서 닫아졌으면 좋겠다는 것이다. . 이러한 모티브에서 구현된 것이 with문 이다. . with open(&#39;test.txt&#39;) as g: print(g.read()) hello hello2 hello3 g.closed . True . 잘 닫아졌다. . - 기본사용법 . with의 사용법은 직관적으로 이해가 가능하지만 그래도 다시한번 살펴보자. . with blabla as variable: yadiyadi yadiyadi2 . (1) with blabla as variable에서 blabla가 실행된다. . (2) blabla의 실행결과로 어떠한 특별한 오브젝트가 만들어지는데 그 오브젝트를 우리가 variable로 부르기로 한다. . (3) 탭으로 들여쓰기된 부분, 즉 yadiyadi, yadiyadi2 가 순서대로 실행된다. . (4) 탭으로 들여쓰기된 부분이 실행되고 난 뒤에 g.closed() 따위의 미리 약속된 어떠한 코드가 실행되는것 같다. . - 동작원리 . 비밀은 __enter__ 와 __exit__ 메소드에 있다. . (for문 복습) for i in ...: 에서 ...에 올 수 있는 오브젝트는 __iter__ 메소드가 정의되어 있어야 한다. 이러한 오브젝트를 iterable한 오브젝트라고 한다. . (with문) with ... as variable: 에서 ...의 실행결과로 생성되는 오브젝트는 __enter__ 와 __exit__ 메소드가 정의되어 있어야 한다. . 이중 __enter__는 with문이 시작되면 자동으로 실행된다. | 이중 __exit__는 with문이 끝나면 자동으로 실행된다. | . - 예제 . class MooYaHo: def __init__(self): print(&#39;init&#39;) def __enter__(self): print(&#39;무야호&#39;) def __exit__(self,exc_type,exc_value,traceback): # self 이외의 3가지 변수는 예외처리에 관련된 변수인데 여기서는 다루지 않음. print(&#39;그만큼 신나시는거지&#39;) . with MooYaHo() as a: print(&#39;.&#39;) . init 무야호 . 그만큼 신나시는거지 . &#54632;&#49688; . 함수도 객체다 | . def myadd(a,b): return a+b . myadd(1,2) . 3 . ?myadd . Signature: myadd(a, b) Docstring: &lt;no docstring&gt; File: c: users owner 파이썬입문 &lt;ipython-input-250-e383cb6c2c80&gt; Type: function . - Type이 function이다? . - myadd 는 function class의 instance이다. . - 결국 myadd 역시 하나의 오브젝트에 불과하다. . higher-order function . myadd(1,2) . 3 . myadd의 입력 1,2는 int class의 인스턴스 오브젝트였음. . 즉 문법의 논리로 보면 함수의 입력에 들어갈 수 있는것은 오브젝트이면 된다. . 그런데 함수 자체도 오브젝트이다 $ to$ 함수도 함수의 입력으로 쓸 수 있다? . - 예제1 . def calc(fun,a,b): return fun(a,b) . calc(myadd,-3,3) . 0 . 이처럼 함수자체를 입력으로 받거나 출력으로 보내는 함수를 higher-order function이라고 한다. .",
            "url": "https://star77sa.github.io/TIL-Blog/jupyter/python/2021/06/27/Python%EC%9E%85%EB%AC%B8-Summary.html",
            "relUrl": "/jupyter/python/2021/06/27/Python%EC%9E%85%EB%AC%B8-Summary.html",
            "date": " • Jun 27, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "R입문",
            "content": ". R은 파이썬, C와 다르게 1부터 시작함 | . &#48289;&#53552; . era &lt;-c(5,4,3,4,5,6) . 벡터의 원소는 모두 같은 &#39;형식&#39;이나 &#39;데이터 형&#39;을 가진다. | . &#53945;&#49688;&#54620; &#54632;&#49688; . seq()는 등차수열을 생성한다. | . seq(from = 0, to = 10, by = 2.5) . &lt;ol class=list-inline&gt; 0 | 2.5 | 5 | 7.5 | 10 | &lt;/ol&gt; seq(0, 10, length = 10) . &lt;ol class=list-inline&gt; 0 | 1.11111111111111 | 2.22222222222222 | 3.33333333333333 | 4.44444444444444 | 5.55555555555556 | 6.66666666666667 | 7.77777777777778 | 8.88888888888889 | 10 | &lt;/ol&gt; rep()는 값이 반복되는 벡터를 생성한다. | . rep(0, times = 10) . &lt;ol class=list-inline&gt; 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | &lt;/ol&gt; rep(c(1,2,3), 2) . &lt;ol class=list-inline&gt; 1 | 2 | 3 | 1 | 2 | 3 | &lt;/ol&gt; rep(c(1,2,3), c(1,2,3)) . &lt;ol class=list-inline&gt; 1 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; rep(c(1,2,3), each = 3) . &lt;ol class=list-inline&gt; 1 | 1 | 1 | 2 | 2 | 2 | 3 | 3 | 3 | &lt;/ol&gt; &#53945;&#49688;&#54620; &#44050; . NA는 &quot;not available&quot; (결측)을 나타낸다. | . mean(x, na.rm = TRUE) . NULL는 &quot;존재하지 않음&quot;을 나타낸다. | . &#54596;&#53552;&#47553; . 특정한 조건에 부합하는 데이터 값만 남기는 기법 | . z &lt;- c(1,8,9,2,7,10,5,6,4,3) z[z %% 2 == 1] . &#50976;&#50857;&#54620; &#54632;&#49688;&#46308; . ifelse(test, yes, no)는 test가 TRUE이면 yes를 값으로 출력, False이면 no로 출력 | . x.1 &lt;- ifelse(x&gt;0, x, 2*x) . identical(x,y)는 x와 y가 동일한 벡터인가를 알려준다. | . all()와 any()는 일부 혹은 모든 인수가 TRUE인지 알려준다. | . names()는 벡터의 개별 요소에 이름을 부여한다. | . paste()는 2개의 문자열 벡터를 붙이는 기능을 한다. | . &#54632;&#49688; . sum.1 &lt;- function(x) { temp &lt;- 0 for(i in 1:length) temp &lt;- temp + x[i] return(temp) } . &#54665;&#47148; . cbind()는 같은 길이의 벡터를 열에 넣어 묶어주는 R함수 | . stat &lt;- cbind(year, game, era) . rbind()는 같은 길이의 벡터를 행에 넣어 묶어주는 R함수 | . M &lt;- rbind(e, f, g) . &#47532;&#49828;&#53944; . p개의 벡터로 구성되는 데이터 객체 | . L &lt;- list(game, era, e) L.1 &lt;- list(game = game, era = era, player = e) . &quot;name&quot; 또는 $name 으로 인덱싱 가능 | . L.1$game L.1[&quot;game&quot;] . &#45936;&#51060;&#53552;&#54532;&#47112;&#51076; . p개의 벡터로 구성되는 데이터 객체 | . 각 요소 벡터의 데이터 형태는 다를 수 있으나 길이는 같다. | . 형태는 행렬과 같으나 열별로만 데이터 형이 같다. | . WS &lt;- data.frame(year, winner, loser, wins, losses) . str() 함수는 데이터프레임의 구조를 파악하는 함수이다. | . str(WS) nrow(WS); ncol(WS); dim(WS), names(WS) #행 갯수, 열 갯수, 행 열 갯수, 헤더 이름 . 열(변수)인덱싱 | . WS$winner WS[,2] WS[[2]] . 행(객체)인덱싱 | . &quot;WS[3,] WS[&quot;3&quot;,] . &#46020;&#50880;&#47568; . R 함수에 대해 알고 싶은 경우 | . help(hist) ?hist . . 1,2 &#51109; &#44620;&#51648; &#51221;&#47532; .",
            "url": "https://star77sa.github.io/TIL-Blog/jupyter/r/2021/06/21/R%EC%9E%85%EB%AC%B8-Summary.html",
            "relUrl": "/jupyter/r/2021/06/21/R%EC%9E%85%EB%AC%B8-Summary.html",
            "date": " • Jun 21, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://star77sa.github.io/TIL-Blog/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://star77sa.github.io/TIL-Blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "수상 . - 장학그… . 프로젝트 . - ㅁㄴㅇㄹ . 프로그래밍 스킬 . - Python . - R . - C / C++ . 봉사활동 . - ㅁㄴㅇㄹ . This website is powered by WebCV 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://star77sa.github.io/TIL-Blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://star77sa.github.io/TIL-Blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}