<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="twitter:card" content="summary_large_image" /><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Deep Learning | kyeong-soo</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Deep Learning" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="「딥러닝 제대로 시작하기」책내용 요약 및 정리" />
<meta property="og:description" content="「딥러닝 제대로 시작하기」책내용 요약 및 정리" />
<link rel="canonical" href="https://star77sa.github.io/TIL-Blog/dl/2021/07/29/DeepLearning.html" />
<meta property="og:url" content="https://star77sa.github.io/TIL-Blog/dl/2021/07/29/DeepLearning.html" />
<meta property="og:site_name" content="kyeong-soo" />
<meta property="og:image" content="https://star77sa.github.io/TIL-Blog/images/chart-preview.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-07-29T00:00:00-05:00" />
<script type="application/ld+json">
{"url":"https://star77sa.github.io/TIL-Blog/dl/2021/07/29/DeepLearning.html","@type":"BlogPosting","headline":"Deep Learning","dateModified":"2021-07-29T00:00:00-05:00","datePublished":"2021-07-29T00:00:00-05:00","image":"https://star77sa.github.io/TIL-Blog/images/chart-preview.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://star77sa.github.io/TIL-Blog/dl/2021/07/29/DeepLearning.html"},"description":"「딥러닝 제대로 시작하기」책내용 요약 및 정리","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/TIL-Blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://star77sa.github.io/TIL-Blog/feed.xml" title="kyeong-soo" /><link rel="shortcut icon" type="image/x-icon" href="/TIL-Blog/images/favicon.ico"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Primer/15.2.0/primer.css" integrity="sha512-xTz2ys4coGAOz8vuV1NcQBkgVmKhsSEtjbqyMJbBHRplFuvKIUo6xhLHpAyPt9mfR6twHJgn9OgVLuqOvjeBhg==" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.css" integrity="sha512-h7nl+xz8wgDlNM4NqKEM4F1NkIRS17M9+uJwIGwuo8vGqIl4BhuCKdxjWEINm+xyrUjNCnK5dCrhM0sj+wTIXw==" crossorigin="anonymous" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/katex.min.js" integrity="sha512-/CMIhXiDA3m2c9kzRyd97MTb3MC6OVnx4TElQ7fkkoRghwDf6gi41gaT1PwF270W6+J60uTmwgeRpNpJdRV6sg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.12.0/contrib/auto-render.min.js" integrity="sha512-Do7uJAaHZm5OLrIv/yN4w0iG1dbu01kzdMNnFfu/mAqgUk6Nniv2JYHcwH+cNwjqgLcqcuBBk+JRvprLVI8azg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha512-0doc9hKxR3PYwso42RD1p5ySZpzzuDiOwMrdCEh2WdJZCjcmFKc/wEnL+z8fBQrnHoiNWbo+3fiGkOYXBdQp4A==" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title") && (el.className != "emoji")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    });
</script>
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/TIL-Blog/">kyeong-soo</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/TIL-Blog/about/">About Me</a><a class="page-link" href="/TIL-Blog/search/">Search</a><a class="page-link" href="/TIL-Blog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Deep Learning</h1><p class="page-description">「딥러닝 제대로 시작하기」책내용 요약 및 정리</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2021-07-29T00:00:00-05:00" itemprop="datePublished">
        Jul 29, 2021
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      8 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/TIL-Blog/categories/#DL">DL</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          <div class="px-2">

    <a href="https://github.com/star77sa/TIL-Blog/tree/master/_notebooks/2021-07-29-DeepLearning.ipynb" role="button" target="_blank">
<img class="notebook-badge-image" src="/TIL-Blog/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div>

          <div class="px-2">
    <a href="https://mybinder.org/v2/gh/star77sa/TIL-Blog/master?filepath=_notebooks%2F2021-07-29-DeepLearning.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/TIL-Blog/assets/badges/binder.svg" alt="Open In Binder"/>
    </a>
</div>

          <div class="px-2">
    <a href="https://colab.research.google.com/github/star77sa/TIL-Blog/blob/master/_notebooks/2021-07-29-DeepLearning.ipynb" target="_blank">
        <img class="notebook-badge-image" src="/TIL-Blog/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#1장-시작하며">1장 시작하며 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#최근까지의-신경망-연구-저조의-이유">최근까지의 신경망 연구 저조의 이유 </a></li>
<li class="toc-entry toc-h3"><a href="#CNN">CNN </a></li>
<li class="toc-entry toc-h3"><a href="#DBN">DBN </a></li>
<li class="toc-entry toc-h3"><a href="#역전파법">역전파법 </a></li>
<li class="toc-entry toc-h3"><a href="#사전훈련">사전훈련 </a></li>
<li class="toc-entry toc-h3"><a href="#자기부호화기">자기부호화기 </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#2장-앞먹임-신경망">2장 앞먹임 신경망 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#앞먹임-신경망">앞먹임 신경망 </a></li>
<li class="toc-entry toc-h3"><a href="#활성화-함수">활성화 함수 </a></li>
<li class="toc-entry toc-h3"><a href="#다층-신경망">다층 신경망 </a></li>
<li class="toc-entry toc-h3"><a href="#회귀">회귀 </a></li>
<li class="toc-entry toc-h3"><a href="#최대우도법(Maximum-Likelihood-Estimation,-이하-MLE)">최대우도법(Maximum Likelihood Estimation, 이하 MLE) </a></li>
<li class="toc-entry toc-h3"><a href="#이진-분류">이진 분류 </a></li>
<li class="toc-entry toc-h3"><a href="#다클래스-분류">다클래스 분류 </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#3장-확률적-경사-하강법">3장 확률적 경사 하강법 </a>
<ul>
<li class="toc-entry toc-h3"><a href="#경사하강법">경사하강법 </a></li>
<li class="toc-entry toc-h3"><a href="#확률적-경사-하강법">확률적 경사 하강법 </a></li>
<li class="toc-entry toc-h3"><a href="#미니배치">미니배치 </a></li>
<li class="toc-entry toc-h3"><a href="#일반화-성능과-과적합">일반화 성능과 과적합 </a></li>
<li class="toc-entry toc-h3"><a href="#과적합을-완화시키는-방법">과적합을 완화시키는 방법 </a>
<ul>
<li class="toc-entry toc-h4"><a href="#가중치-감쇠">가중치 감쇠 </a></li>
<li class="toc-entry toc-h4"><a href="#가중치-상한">가중치 상한 </a></li>
<li class="toc-entry toc-h4"><a href="#드롭아웃">드롭아웃 </a></li>
</ul>
</li>
</ul>
</li>
</ul><!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2021-07-29-DeepLearning.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h2 id="1장-시작하며">
<a class="anchor" href="#1%EC%9E%A5-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>1장 시작하며<a class="anchor-link" href="#1%EC%9E%A5-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0"> </a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="최근까지의-신경망-연구-저조의-이유">
<a class="anchor" href="#%EC%B5%9C%EA%B7%BC%EA%B9%8C%EC%A7%80%EC%9D%98-%EC%8B%A0%EA%B2%BD%EB%A7%9D-%EC%97%B0%EA%B5%AC-%EC%A0%80%EC%A1%B0%EC%9D%98-%EC%9D%B4%EC%9C%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a>최근까지의 신경망 연구 저조의 이유<a class="anchor-link" href="#%EC%B5%9C%EA%B7%BC%EA%B9%8C%EC%A7%80%EC%9D%98-%EC%8B%A0%EA%B2%BD%EB%A7%9D-%EC%97%B0%EA%B5%AC-%EC%A0%80%EC%A1%B0%EC%9D%98-%EC%9D%B4%EC%9C%A0"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ol>
<li>역전파법에 의한 신경망 학습이 2층정도의 신경망에선 잘 이뤄졌지만 그보다 많은 층수에선 기대했던 결과를 얻지 못함. 과적합이 나타남. (예외 : CNN)</li>
<li>신경망은 학습을 위한 여러 파라미터로 층수나 유닛의 수를 갖는데 이 파라미터가 최종적으로 어떻게 성능으로 이어지는지 알 수 없었음. 파라미터 결정에 노하우는 있지만 이론이 없었음.</li>
</ol>
<p>이런 이유로 머신러닝보다 뒤떨어진다는 평가를 받음.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="CNN">
<a class="anchor" href="#CNN" aria-hidden="true"><span class="octicon octicon-link"></span></a>CNN<a class="anchor-link" href="#CNN"> </a>
</h3>
<ul>
<li>특정한 이미지 처리를 수행하는 층이 여러개 쌓인 구조를 갖는, 층간의 결합 밀도가 낮은 신경망</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="DBN">
<a class="anchor" href="#DBN" aria-hidden="true"><span class="octicon octicon-link"></span></a>DBN<a class="anchor-link" href="#DBN"> </a>
</h3>
<ul>
<li>일반적인 신경망과 유사하게 다층 구조를 갖는 그래프 모델(graph model). 이 모델의 동작은 확률적으로 기술되며, 주로 데이터의 생성 모델로 쓰였다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="역전파법">
<a class="anchor" href="#%EC%97%AD%EC%A0%84%ED%8C%8C%EB%B2%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>역전파법<a class="anchor-link" href="#%EC%97%AD%EC%A0%84%ED%8C%8C%EB%B2%95"> </a>
</h3>
<ul>
<li>샘플에 대한 신경망의 오차(목표 출력과 실제 출력의 차이)를 다시 출력층에서부터 입력층으로 거꾸로 전파시켜 각 층의 가중치의 기울기를 계산하는 방법</li>
</ul>
<h3 id="사전훈련">
<a class="anchor" href="#%EC%82%AC%EC%A0%84%ED%9B%88%EB%A0%A8" aria-hidden="true"><span class="octicon octicon-link"></span></a>사전훈련<a class="anchor-link" href="#%EC%82%AC%EC%A0%84%ED%9B%88%EB%A0%A8"> </a>
</h3>
<ul>
<li>사용하려는 신경망을 학습기키기 전 층단위의 학습을 거치는 것으로 더 나은 초기값을 얻는 방법. 딥 러닝 붐의 계기가 되었지만, 필수적인 것만은 아님. CNN같은 경우는 처음부터 사전훈련을 필요로 하지 않는다.</li>
</ul>
<h3 id="자기부호화기">
<a class="anchor" href="#%EC%9E%90%EA%B8%B0%EB%B6%80%ED%98%B8%ED%99%94%EA%B8%B0" aria-hidden="true"><span class="octicon octicon-link"></span></a>자기부호화기<a class="anchor-link" href="#%EC%9E%90%EA%B8%B0%EB%B6%80%ED%98%B8%ED%99%94%EA%B8%B0"> </a>
</h3>
<ul>
<li>입력으로부터 계산되는 출력이 입력 자체와 비슷해지도록 훈련되는 신경망. 다시말해 자기부호화기의 목표 출력은 입력 그 자체이며, 비지도 학습으로 학습이 이루어진다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>다층 신경망은 파라미터를 랜덤하게 초기화하면 학습이 잘 되지 않지만, 층마다 비지도 학습 형태의 사전훈련을 거친 뒤 얻은 파라미터를 초깃값으로 사용하면 학습이 잘된다고 한다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h2 id="2장-앞먹임-신경망">
<a class="anchor" href="#2%EC%9E%A5-%EC%95%9E%EB%A8%B9%EC%9E%84-%EC%8B%A0%EA%B2%BD%EB%A7%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>2장 앞먹임 신경망<a class="anchor-link" href="#2%EC%9E%A5-%EC%95%9E%EB%A8%B9%EC%9E%84-%EC%8B%A0%EA%B2%BD%EB%A7%9D"> </a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="앞먹임-신경망">
<a class="anchor" href="#%EC%95%9E%EB%A8%B9%EC%9E%84-%EC%8B%A0%EA%B2%BD%EB%A7%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>앞먹임 신경망<a class="anchor-link" href="#%EC%95%9E%EB%A8%B9%EC%9E%84-%EC%8B%A0%EA%B2%BD%EB%A7%9D"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/%ED%8D%BC%EC%85%89%ED%8A%B8%EB%A1%A0.png" alt="" style="max-width: 300px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>층 모양으로 늘어선 유닛이 인접한 층(layer)들과만 결합하는 구조를 가지며 정보가 입력 측으로부터 출력 측으로 한 방향으로만 흐르는 신경망. <code>다층 퍼셉트론(multi-layer perceptron)</code>이라 부르기도 한다.</p>
<p>신경망을 구성하는 각 유닛은 복수의 입력을 받아 하나의 출력을 계산한다. 입력은 가중치 4개를 받지만, 이 유닛이 받는 총 입력은 다음과 같이 바이어스를 추가하여 5개이다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>
$$ u = w_1x_1 + w_2x_2 + w_3x_3 + w_4x_4 + b $$
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>각 입력마다 다른 <code>가중치(weight)</code> w1, w2, w3, w4를 곱한 값을 모두 합하고, 이에 <code>바이어스(bias)</code>라 불리는 값을 더한 값이 된다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>이 유닛의 출력 z 는 총 입력 u에 대한 <code>활성화 함수(activation function)</code>라 불리는 함수 f의 함숫값이다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>유닛마다 각각 다른 가중치 w가 주어진다</p>
<p>세 개의 유닛이 받는 입력은 각각 다음과 같이 계산된다.</p>
<p>$$ u_1 = w_{11}x_1 + w_{12}x_2 + w_{13}x_3 + w_{14}x_4 + b_1 $$</p>
<p>$$ u_1 = w_{21}x_1 + w_{22}x_2 + w_{23}x_3 + w_{24}x_4 + b_2 $$</p>
<p>$$ u_1 = w_{31}x_1 + w_{32}x_2 + w_{33}x_3 + w_{34}x_4 + b_3 $$</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>여기에 다시 활성화 함수를 적용하여 아래 식과 같은 출력이 된다.</p>
<p>
$$ z_{j} = f(u_{j}) \,\,\,\,\,\,(j = 1, 2, 3) $$
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="활성화-함수">
<a class="anchor" href="#%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>활성화 함수<a class="anchor-link" href="#%ED%99%9C%EC%84%B1%ED%99%94-%ED%95%A8%EC%88%98"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>유닛의 활성화 함수로는 통상적으로 단조증가하는 비선형함수가 사용된다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/%EC%8B%9C%EA%B7%B8%EB%AA%A8%EC%9D%B4%EB%93%9C.png" alt="" style="max-width: 500px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<code>로지스틱 함수</code>는 (0, 1)을 치역으로, <code>쌍곡선 정접함수</code>는 (-1, 1)을 치역으로 갖는다.</li>
<li>로지스틱함수와 쌍곡선 정접함수는 모두 시그모이드 함수이다.
출력이 서서히 그리고 매끄럽게 변화하는 특징을 갖는다. 이러한 특징은 생물의 신경세포가 갖는 성질을 모델링한 것이다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/%EB%9E%A8%ED%94%84%ED%95%A8%EC%88%98.png" alt="" style="max-width: 500px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>최근에 시그모이드 대신 <code>램프 함수</code>가 자주 사용된다. 간단하게 줄여 rectifier라고도 부른다.</p>
<p>램프 함수는 z = u 인 선형 함수 중 u &lt; 0 인 부분을 f(u) = 0으로 바꾼 단순한 함수이다.</p>
<p>위의 두 함수보다 학습이 빠르고 최종 결과가 더 좋은 경우가 많아 현재 가장 많이 사용된다.</p>
<p>이 함수를 갖는 유닛을 ReLU (Rectified Linear Unit)라고 표기하기도 한다.</p>
</li>
</ul>
<ul>
<li>
<p>램프 함수와 관계 깊은 <code>맥스아웃</code>은 K개의 유닛을 하나로 합친 것과 같은 구조를 갖는다.</p>
<p>각각의 총 입력을 uj1, uj2 ... ujk 별로 따로 계산한 후, 그중 최댓값을 이 유닛의 출력으로 한다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>신경망에서는 각 유닛의 활성화 함수가 비선형성을 갖는 것이 본질적으로 중요하지만, 부분적으로 선형사상을 사용하는 경우가 있다.</p>
<p>회귀 문제에선 출력층에서 <code>항등사상</code>을, 클래스 분류에서는 <code>소프트맥스 함수</code>를 사용한다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="다층-신경망">
<a class="anchor" href="#%EB%8B%A4%EC%B8%B5-%EC%8B%A0%EA%B2%BD%EB%A7%9D" aria-hidden="true"><span class="octicon octicon-link"></span></a>다층 신경망<a class="anchor-link" href="#%EB%8B%A4%EC%B8%B5-%EC%8B%A0%EA%B2%BD%EB%A7%9D"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/%EB%8B%A4%EC%B8%B5.png" alt="" style="max-width: 500px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>정보는 왼쪽에서 오른쪽 한 방향으로 전달, 순서대로 각 층을 l = 1, 2, 3으로 표기</p>
<p>l = 1인 층을 <code>입력층</code></p>
<p>l = 2인 층을 <code>중간층</code> 또는 <code>은닉층</code></p>
<p>l = 3인 층을 <code>출력층</code> 이라고 한다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>중간층에선 x를 입력으로 받는데, 그 다음 층에서는 중간층의 출력을 입력으로 받는다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>각 층에서 서로 다른 활성화 함수를 사용하여도 무방하다. 특히 출력층 유닛의 활성화 함수는 일반적으로 중간층과는 다른 활성화 함수를 사용한다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>하나의 입력 x에 대하여 바람직한 출력을 d라고 할 때, 이러한 입출력 쌍이 어러개 주어졌다고 하면</p>
<p>신경망의 출력 y이 최대한 d와 가까워지도록 w를 조정해야한다. 이것을 <code>학습</code>이라고 부른다.</p>
<p>이 때 신경망이 나타내는 함수와 훈련 데이터와의 가까운 정도 즉 거리를 어떻게 측정할 것인지가 중요한데</p>
<p>이 거리의 척도를 <code>오차함수</code>라고 부른다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>오차함수 = 손실함수. (나쁜 정도를 측정하는 함수라 보면 될듯 작을수록 좋다!)</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<table>
<thead>
<tr>
<th>문제의 유형</th>
<th>출력층에 쓰이는 활성화 함수</th>
<th>오차함수</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>회귀</strong></td>
<td>항등사상</td>
<td>제곱오차</td>
</tr>
<tr>
<td><strong>이진 분류</strong></td>
<td>로지스틱 함수</td>
<td>식 2-8</td>
</tr>
<tr>
<td><strong>다클래스 분류</strong></td>
<td>소프트맥스 함수</td>
<td>교차 엔트로피</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="회귀">
<a class="anchor" href="#%ED%9A%8C%EA%B7%80" aria-hidden="true"><span class="octicon octicon-link"></span></a>회귀<a class="anchor-link" href="#%ED%9A%8C%EA%B7%80"> </a>
</h3>
<p>출력이 연속값을 갖는 함수를 대상으로 훈련 데이터를 잘 재현하는 함수를 찾는 것</p>
<p>목적으로 하는 함수와 같은 치역을 갖는 함수를 출력층의 활성화 함수로 골라야 함.</p>
<p>ex) 목표함수의 치역이 [-1 : 1]인 경우 쌍곡선 정접함수, 목표함수가 (-inf : inf)인 경우 항등사상이 적합하다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="최대우도법(Maximum-Likelihood-Estimation,-이하-MLE)">
<a class="anchor" href="#%EC%B5%9C%EB%8C%80%EC%9A%B0%EB%8F%84%EB%B2%95(Maximum-Likelihood-Estimation,-%EC%9D%B4%ED%95%98-MLE)" aria-hidden="true"><span class="octicon octicon-link"></span></a>최대우도법(Maximum Likelihood Estimation, 이하 MLE)<a class="anchor-link" href="#%EC%B5%9C%EB%8C%80%EC%9A%B0%EB%8F%84%EB%B2%95(Maximum-Likelihood-Estimation,-%EC%9D%B4%ED%95%98-MLE)"> </a>
</h3>
<p>모수적인 데이터 밀도 추정 방법으로써 파라미터 $\theta = (\theta_1, \cdots, \theta_m)$으로 구성된 어떤 확률밀도함수 $P(x|\theta)$에서 관측된 표본 데이터 집합을 $x = (x_1, x_2, \cdots, x_n)$이라 할 때, 이 표본들에서 파라미터 $\theta = (\theta_1, \cdots, \theta_m)$를 추정하는 방법이다.</p>
<p>데이터가 먼저 주어지고, 이를 이용하여 함수의 파라미터를 추정하는 것</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="이진-분류">
<a class="anchor" href="#%EC%9D%B4%EC%A7%84-%EB%B6%84%EB%A5%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>이진 분류<a class="anchor-link" href="#%EC%9D%B4%EC%A7%84-%EB%B6%84%EB%A5%98"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="다클래스-분류">
<a class="anchor" href="#%EB%8B%A4%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B6%84%EB%A5%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>다클래스 분류<a class="anchor-link" href="#%EB%8B%A4%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%B6%84%EB%A5%98"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>클래스 분류란 입력 x를 내용에 따라 유한개의 클래스로 분류하는 문제.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>신경망의 출력층에 분류하려는 클래스 수 L과 같은 수의 유닛을 구성, 이 층의 활성화 함수를 소프트맥스로 선택.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/%EC%86%8C%ED%94%84%ED%8A%B8%EB%A7%A5%EC%8A%A4.png" alt="" style="max-width: 300px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>소프트맥스 함수에서는 이 층 모든 유닛의 총 입력으로부터 결정되는 점이 다른 함수들과 다르다.</p>
<p>출력 y1 y2 ... yn 총합이 항상 1이 되는 것에 주의</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<hr>
<h2 id="3장-확률적-경사-하강법">
<a class="anchor" href="#3%EC%9E%A5-%ED%99%95%EB%A5%A0%EC%A0%81-%EA%B2%BD%EC%82%AC-%ED%95%98%EA%B0%95%EB%B2%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>3장 확률적 경사 하강법<a class="anchor-link" href="#3%EC%9E%A5-%ED%99%95%EB%A5%A0%EC%A0%81-%EA%B2%BD%EC%82%AC-%ED%95%98%EA%B0%95%EB%B2%95"> </a>
</h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="경사하강법">
<a class="anchor" href="#%EA%B2%BD%EC%82%AC%ED%95%98%EA%B0%95%EB%B2%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>경사하강법<a class="anchor-link" href="#%EA%B2%BD%EC%82%AC%ED%95%98%EA%B0%95%EB%B2%95"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>학습의 목표는 선택한 오차함수에 대하여 최솟값을 주는 오차함수를 구하는 것이지만,</p>
<p>오차함수는 일반적인 경우 볼록함수가 아니므로 전역극소점(global minimum)을 직접 구하는 것은 통상적으로 불가능하다.</p>
<p>대신에 국소 극소점(local minimum)을 구하는 것을 생각해보면, 국소 극소점은 여러개 존재하므로</p>
<p>구한 극소점이 우연히 전역 극소점일 가능성은 낮다. 다만 국소 극소점이 충분히 작다면 목적으로 하는 클래스 분류나</p>
<p>회귀 문제를 나름대로 잘 풀 수도 있다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/%EA%B2%BD%EC%82%AC%ED%95%98%EA%B0%95%EB%B2%95.png" alt="" style="max-width: 500px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>현재의 w를 음의 기울기 방향으로 조금씩 움직이는 것을 여러번 반복하여 언젠가는 극소점에 도달하는 것이다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>최소화 방법에 목적함수의 2차미분을 이용하는 뉴턴법 등이 있지만 문제의 크기가 큰 경우에 2차 미분에 대한 계산이</p>
<p>어렵기에 경사하강법은 사용할 수 있는 몇 안되는 유효한 방법 중 하나가 된다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="확률적-경사-하강법">
<a class="anchor" href="#%ED%99%95%EB%A5%A0%EC%A0%81-%EA%B2%BD%EC%82%AC-%ED%95%98%EA%B0%95%EB%B2%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>확률적 경사 하강법<a class="anchor-link" href="#%ED%99%95%EB%A5%A0%EC%A0%81-%EA%B2%BD%EC%82%AC-%ED%95%98%EA%B0%95%EB%B2%95"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>위에서는 각 샘플의 오차들의 합을 이용하여 한 방법인데, 이를 <code>배치학습</code>이라고 한다.</p>
<p><code>확률적 경사하강법</code>은 이와 대조적으로 샘플의 일부, 극단적으론 샘플 하나만을 사용하여 파라미터를 업데이트 한다.</p>
<p>1회 진행할때마다 다른 샘플을 선택하여 업데이트를 한다.</p>
<p>배치학습과 비교하여 장점은</p>
<ol>
<li>
<p>훈련 데이터에 잉여성이 있을 때 계산 효율이 향상되고 학습이 빨리 진행된다.</p>
</li>
<li>
<p>국소 극소점에 갇히는 위험을 줄일 수 있다. 목적함수가 w를 업데이트할 때마다 달라지므로.</p>
</li>
</ol>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="미니배치">
<a class="anchor" href="#%EB%AF%B8%EB%8B%88%EB%B0%B0%EC%B9%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>미니배치<a class="anchor-link" href="#%EB%AF%B8%EB%8B%88%EB%B0%B0%EC%B9%98"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>샘플 전체를 선택 : 경사하강법 / 배치학습</p>
<p>샘플 1개를 선택 : 확률적 경사하강법</p>
<p>샘플 여러개를 선택 : 미니배치</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>미니배치의 크기를 결정하는 통계적인 방법이 따로 있지는 않지만, 확률적 경사하강법의 장점과 병렬 계산 자원의 유효한 이용을 비교하여</p>
<p>대체로 10~100개 샘플 전후로 결정하는 경우가 많다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>다클래스 분류 문제에서는 미니배치 간의 가중치 업데이트 값을 일정하게 하기 위해 미니배치마다 각 클래스의 샘플이 하나 이상 들어가도록 하는 것이 이상적</p>
<p>따라서 클래스 수가 10~100개 정도이면서 각 클래스의 출현 빈도가 서로 같을 때에는 분류하려는 클래스 수와 같은 크기의 미니배치를 생성하는 것이 좋다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>미니 배치의 크기를 너무 작게 잡는 것은 별로 좋지 않다. (확률적 경사 하강법의 장점을 완전히 활용하지 못하게 하므로)</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>크기를 크게할수록 학습이 빨라지지만 계산속도(단위시간당 업데이트 횟수)는 오히려 느려진다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="일반화-성능과-과적합">
<a class="anchor" href="#%EC%9D%BC%EB%B0%98%ED%99%94-%EC%84%B1%EB%8A%A5%EA%B3%BC-%EA%B3%BC%EC%A0%81%ED%95%A9" aria-hidden="true"><span class="octicon octicon-link"></span></a>일반화 성능과 과적합<a class="anchor-link" href="#%EC%9D%BC%EB%B0%98%ED%99%94-%EC%84%B1%EB%8A%A5%EA%B3%BC-%EA%B3%BC%EC%A0%81%ED%95%A9"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>학습의 진짜 목적은 이미 주어진 훈련 데이터가 아니라 앞으로 주어질 '미지의' 샘플 x에 대한 정확한 추정을 가능토록 하는 것</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>훈련 데이터에 대한 오차 <code>훈련오차(training error)</code></p>
<p>샘플 모집단에 대한 오차에 대한 기댓값 <code>일반화 오차(generalization error)</code></p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>일반화 오차가 작도록 하는 것이 목표이지만, 일반화 오차는 통계적인 기댓값이므로 훈련 오차처럼 계산할 수가 없다.</p>
<p>그러므로 훈련 데이터와 다른 별도의 샘플 집합을 준비한 후, 이 샘플 집합에 대해서 훈련 오차와 같은 방법으로 계산한 오차를 기준으로 삼는다.</p>
<p>이를 목적으로 준비하는 데이터를 <code>테스트 데이터(test data)</code>, 테스트 데이터에 대한 오차를 <code>테스트 오차(test error)</code></p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<code>학습곡선</code> : 학습에 의한 파라미터 변화에 따라 훈련 오차 및 테스트 오차가 어떻게 변화하는지에 대한 곡선</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/overfit.png" alt="" style="max-width: 500px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>일반적으로 훈련 오차는 파라미터의 업데이트를 반복함에 따라 대개 단조적으로 감소한다.</p>
<p>그에 비해 테스트 오차는 학습 초기에는 훈련 오차와 같이 감소하다가 학습도중에 자주 훈련오차와 많이 달라진 값을 갖게된다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<code>과적합(overfitting)</code> : 훈련 오차와 일반화 오차가 동떨어진 값을 갖는 상태가 되는 것</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<code>조기종료(early stopping)</code> : 파라미터 업데이트에 따라 테스트 오차가 증가한다면 더 이상의 학습은 오히려 방해가 되기에 그 시점에서 학습을 종료</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="과적합을-완화시키는-방법">
<a class="anchor" href="#%EA%B3%BC%EC%A0%81%ED%95%A9%EC%9D%84-%EC%99%84%ED%99%94%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95" aria-hidden="true"><span class="octicon octicon-link"></span></a>과적합을 완화시키는 방법<a class="anchor-link" href="#%EA%B3%BC%EC%A0%81%ED%95%A9%EC%9D%84-%EC%99%84%ED%99%94%EC%8B%9C%ED%82%A4%EB%8A%94-%EB%B0%A9%EB%B2%95"> </a>
</h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>과적합이란 학습 시에 오차함수 값이 작은 국소 극소점에 갇힌 상황이라고 해석할 수 있다.</p>
<p>신경망의 자유도(주로 가중치의 수)가 높을수록 그럴 가능성이 높다고 할 수 있다.</p>
<p>다만 신경망의 자유도는 그 표현 능력과 직결된다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>학습 시에 가중치의 자유도를 제약하는 <code>규제화(regularization)</code>에 의해 과적합 문제를 완화시키는 방법 : 가중치 감쇠, 가중치 상한, 드롭아웃</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="가중치-감쇠">
<a class="anchor" href="#%EA%B0%80%EC%A4%91%EC%B9%98-%EA%B0%90%EC%87%A0" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>가중치 감쇠</code><a class="anchor-link" href="#%EA%B0%80%EC%A4%91%EC%B9%98-%EA%B0%90%EC%87%A0"> </a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>오차함수에 가중치의 제곱합(norm의 제곱)을 더한 뒤 이를 최소화 하는 방법.</p>
<p>가중치는 자신의 크기에 비례하는 속도로 항상 감쇠하도록 업데이트된다.</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>가중치 감쇠는 가중치 W에만 적용하며 바이어스b에는 적용하지 않는다.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="가중치-상한">
<a class="anchor" href="#%EA%B0%80%EC%A4%91%EC%B9%98-%EC%83%81%ED%95%9C" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>가중치 상한</code><a class="anchor-link" href="#%EA%B0%80%EC%A4%91%EC%B9%98-%EC%83%81%ED%95%9C"> </a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>각 유닛의 입력 측 결합의 가중치에 대해서 그 제곱합의 최댓값을 제약하는 방법</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>
$$ \sum_i w_{ji}^2 &lt; c $$
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>이 부등식을 만족하지 않는 경우에는 가중치에 미리 정한 (1보다 작은) 상수를 곱하여 부등식을 만족하도록 한다.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>가중치 감쇠보다 뛰어난 효과, 드롭아웃과 함께 사용하면 특히 높은 효과.</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="드롭아웃">
<a class="anchor" href="#%EB%93%9C%EB%A1%AD%EC%95%84%EC%9B%83" aria-hidden="true"><span class="octicon octicon-link"></span></a><code>드롭아웃</code><a class="anchor-link" href="#%EB%93%9C%EB%A1%AD%EC%95%84%EC%9B%83"> </a>
</h4>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>드롭아웃 : 다층 신경망의 유닛 중 일부를 확률적으로 선택하여 학습하는 방법</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><figure>
  
    <img class="docimage" src="/TIL-Blog/images/copied_from_nb/my_icons/%EB%93%9C%EB%A1%AD%EC%95%84%EC%9B%83.png" alt="" style="max-width: 500px">
    
    
</figure>
</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>학습 시</p>
<p>중간층과 입력층 각 층의 유닛 중 미리 정해둔 비율 p만큼을 선택하고 선택되지 않은 유닛을 무효화.</p>
<p>가상의 신경망을 구성하는 유닛은 가중치를 업데이트할 때 마다 다시 무작위로 선택</p>
</li>
<li>
<p>추론 시</p>
<p>모든 유닛을 사용하여 앞먹임 계산을 한다.</p>
<p>드롭아웃에서 무효화된 유닛은 일률적으로 출력을 p배로 한다.
추론시의 유닛 수가 학습 시에 비해 1/p배 된 것과 같기 때문에 이를 보상하기 위함</p>
<p>(추론 시가 학습시보다 유닛 수가 많음.)</p>
</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>드롭아웃이 목적하는 바 : 신경망의 자유도(가중치의 수)를 강제적으로 낮추고 과적합을 회피하는 것</li>
</ul>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<ul>
<li>
<p>이 과정은 드롭아웃을 거친 신경망을 여러 개 훈련한 후 여러개의 신경망으로 부터 얻은 결괏값의 평균을 내는 것과 같은 효과가 있다고 볼 수 있다.</p>
<p>다수의 신경망의 평균을 내면 추론의 정확도가 일반적으로 좋아진다고 알려져 있으며 드롭아웃은 같은 효과를 보다 적은 계산 비용으로 얻을 수 있는 방법이라 볼 수 있다.</p>
</li>
</ul>

</div>
</div>
</div>
</div>



  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="star77sa/TIL-Blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script><a class="u-url" href="/TIL-Blog/dl/2021/07/29/DeepLearning.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/TIL-Blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/TIL-Blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/TIL-Blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>TIL-Blog</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/star77sa" title="star77sa"><svg class="svg-icon grey"><use xlink:href="/TIL-Blog/assets/minima-social-icons.svg#github"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
